# 二叉树

## 遍历方式
- 深度遍历
  - 前序遍历 根结点 ---> 左子树 ---> 右子树
  - 中序遍历 左子树---> 根结点 ---> 右子树
  - 后序遍历 左子树 ---> 右子树 ---> 根结点
- 广度遍历
  - 按层次遍历

前序遍历

```go
type TreeNode struct {
  val   int
  lNode *TreeNode
  rNode *TreeNode
}

func Travel(root *TreeNode) {
  fmt.Println(root.val)
  Travel(root.lNode)
  Travel(root.rNode)
}
```

### 二叉查找树的遍历恢复/构建
1. 有序数组构建二叉树
   
2. 二叉树如何恢复为有序数组
  通过前序遍历，中序遍历可以恢复二叉树   
  通过后序遍历，中序遍历可以恢复二叉树
  前提：所有元素没有重复的，根据前序/后序遍历，可以知道跟节点是那个， 那么在中序遍历的序列中，该值的昨天是左子树，右边是右子树
  对于查找二叉树，通过前序/后续 经过排序可以得到中序遍历




## 二叉查找树

（Binary Search Tree）（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；
所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。

- 左边的值（包括所有子树）都小于根节点，右边的值都大于根节点。所以可以直接查找
- 由于不会有重复值，所以插入也很简单，类似查找
- 删除比较复杂，
    1. 如果该节点没有左/右子树，就拿右/左替换就可以
    2. 两个都没有，直接删除
    3. 如果左右子树都有，可以拿左子树的最右节点或者右子树的最左节点替换。同时被替换的按照情况一再进行替换。


## B数
符合这几个特点：
- 所有数值都是按照递增排序的
- 节点有N个值，那么这个节点有N+1个子节点
- 所有叶子节点都在同一层
- 所有节点（除根和叶子节点）最少有ceil(m/2)个个子树（m是高度）

说n阶数，说的是一个节点最多有n个子节点
树的节点和树的高度有个计算公式（太复杂了，没记住）  


## B+树
相对于B树来说，将所有的数据都存储到叶子节点。同时有个好处就是遍历。相对于B树来说可以方便的进行遍历
这也是为什么数据库会采用B+树，因为数据库中有很多需要遍历的操作。
能更快遍历的原因是在叶子节点直接增加了顺序的指针，因此可以快速遍历叶子节点

## B*树
针对B+树的变种，在B+树的基础上，在中间节点增加指向兄弟的节点。
相对于B+树，插入效率底了，存储效率高了