# 二叉树
## 遍历方式
- 深度遍历
  - 前序遍历 根结点 ---> 左子树 ---> 右子树
  - 中序遍历 左子树---> 根结点 ---> 右子树
  - 后序遍历 左子树 ---> 右子树 ---> 根结点
- 广度遍历
  - 按层次遍历

前序遍历
```go
type TreeNode struct {
  val   int
  lNode *TreeNode
  rNode *TreeNode
}

func Travel(root *TreeNode) {
  fmt.Println(root.val)
  Travel(root.lNode)
  Travel(root.rNode)
}
```

二叉查找树的遍历恢复，

通过前序遍历，中序遍历可以恢复二叉树   
通过后序遍历，中序遍历可以恢复二叉树
前提：所有元素没有重复的，根据前序/后序遍历，可以知道跟节点是那个， 那么在中序遍历的序列中，该值的昨天是左子树，右边是右子树




对于查找二叉树，通过前序/后续 经过排序可以得到中序遍历




## 二叉查找树

（Binary Search Tree）（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；
所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。

- 左边的值（包括所有子树）都小于根节点，右边的值都大于根节点。所以可以直接查找
- 由于不会有重复值，所以插入也很简单，类似查找
- 删除比较复杂，
    1. 如果该节点没有左/右子树，就拿右/左替换就可以
    2. 两个都没有，直接删除
    3. 如果左右子树都有，可以拿左子树的最右节点或者右子树的最左节点替换。同时被替换的按照情况一再进行替换。


