# 算法图解

## 第一章：算法简介



## 第二章：选择排序



## 第三章：递归

递归函数有两个条件

- 基线条件 base case (函数不再调用自己)
- 递归条件 recuisive case（函数调用自己）



## 第四章： 快速排序

> 分而治之 divide and conquer D&C 

```python
def quicksort(array):
  if len(array)<2:
    return array
  else:
    p=array[0]
    less=[i for i in array[1:] if i<=pivot]
    greater=[i for i in array[1:] if i>p]
    return quicksort(less)+[p]+quicksort(greater)  
```



## 第五章：散列表 hash table

- python 的散列表是dict

散列表

- 装填因子=散列表包含的元素数/位置总数
- ​

## 第六章：广度优先搜索(BFS)breadth-first search

广度优先搜索让你能够找出两样东西之间的最短距离

需要两个步骤。
(1) 使用图来建立问题模型。
(2) 使用广度优先搜索解决问题。

图算法

散列表（字典）+队列

字典用于存储图的关系，队列用于遍历

每次检查过的需要加上标记不再检查，否则可能陷入循环

## 深度优先搜索(DFS)

[link](https://blog.csdn.net/raphealguo/article/details/7560918)

深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念

## 深度与广度的比较

从上一篇《[【算法入门】广度/宽度优先搜索(BFS)](http://blog.csdn.net/raphealguo/article/details/7523411) 》中知道，我们搜索一个图是按照树的层次来搜索的。

我们假设一个节点衍生出来的相邻节点平均的个数是N个，那么当起点开始搜索的时候，队列有一个节点，当起点拿出来后，把它相邻的节点放进去，那么队列就有N个节点，当下一层的搜索中再加入元素到队列的时候，节点数达到了N2，你可以想想，一旦N是一个比较大的数的时候，这个树的层次又比较深，那这个队列就得需要很大的内存空间了。

于是广度优先搜索的缺点出来了：在树的层次较深&子节点数较多的情况下，消耗内存十分严重。广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况。

那么深度优先就可以克服这个缺点，因为每次搜的过程，每一层只需维护一个节点。但回过头想想，广度优先能够找到最短路径，那深度优先能否找到呢？深度优先的方法是一条路走到黑，那显然无法知道这条路是不是最短的，所以你还得继续走别的路去判断是否是最短路？

于是深度优先搜索的缺点也出来了：难以寻找最优解，仅仅只能寻找有解。其优点就是内存消耗小，克服了刚刚说的广度优先搜索的缺点。



## 第七章 狄克斯特拉算法

处理加权图

(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。
(2) 更新该节点的邻居的开销，其含义将稍后介绍。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径

不能将狄克斯特拉算法用于包含负权边的图。在包含负权边的图中，要找出最短路径，可使用另一种算法——贝尔曼福德算法（Bellman-Fordalgorithm）

因为负的边权会造成已经处理过的边再次处理，处理过的边不能再处理，因为已经是最便宜的节点了。



## 第八章 贪婪算法

没有快速算法的问题（NP）

不求最优解，找个差不多的解

 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
 涉及“所有组合”的问题通常是NP完全问题。
 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

## 第九章：动态规划



动态规划能够解决的问题

 需要在给定约束条件下优化某种指标时，动态规划很有用。
 问题可分解为离散子问题时，可使用动态规划来解决。
 每种动态规划解决方案都涉及网格。
 单元格中的值通常就是你要优化的值。
 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
 没有放之四海皆准的计算动态规划解决方案的公式。



## 第十章：K近邻算法

 KNN用于分类和回归，需要考虑最近的邻居。
 分类就是编组。
 回归就是预测结果（如数字）。
 特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。
 能否挑选合适的特征事关KNN算法的成败。



## 第十一章：拓展

- 并行计算

 并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之
间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组
合并成一个有序数组，那么合并也是需要时间的。
 负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核
A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意
味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两
个内核都一样忙呢？

- 分布式计算：Map reduce



Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站
上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你
发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道
私钥，就只有你才能解密消息！
Diffie-Hellman算法及其替代者RSA依然被广泛使用。如果你对加密感兴趣，先着手研究
Diffie-Hellman算法是不错的选择：它既优雅又不难理解。









## 第11 章 接下来如何做

接下来如何做
本章内容
 概述本书未介绍的10种算法以及它们很有用的原因。
 如何根据兴趣选择接下来要阅读的内容。
11.1 树
在前面的二分查找示例中，每当用户登录Facebook时，Facebook都必须在一个庞大的数组中
查找，核实其中是否包含指定的用户名。前面说过，在这种数组中查找时，最快的方式是二分查
找，但问题是每当有新用户注册时，都必须将其用户名插入该数组并重新排序，因为二分查找仅
在数组有序时才管用。如果能将用户名插入到数组的正确位置就好了，这样就无需在插入后再排
序。为此，有人设计了一种名为二叉查找树（binary search tree）的数据结构。
第11 章
11.1 树 169
1
2
3
4
5
11
6
7
8
9
10
二叉查找树类似于下面这样。
对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。
假设你要查找Maggie。为此，你首先检查根节点。
Maggie排在David的后面，因此你往右边找。
170 第11 章 接下来如何做
Maggie排在Manning前面，因此你往左边找。
终于找到了Maggie！这几乎与二分查找一样！在二叉查找树中查找节点时，平均运行时间为
O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所
需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插
入和删除操作的速度要快得多。
二叉查找树也存在一些缺点，例如，不能随机访问，就像不能这么说：“给我第五个元素。”
在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。假设二叉查找树像下面这样处于不
平衡状态。
11.3 傅里叶变换 171
1
2
3
4
5
11
6
7
8
9
10
注意，这棵树是向右倾斜的，因此性能不佳。也有一些处于平衡状态的特殊二叉查找树，
如红黑树。
那在什么情况下使用二叉查找树呢？B树是一种特殊的二叉树，数据库常用它来存储数据。
如果你对数据库或高级数据结构感兴趣，请研究如下数据结构：B树，红黑树，堆，
伸展树。
11.2 反向索引
这里非常简单地说说搜索引擎的工作原理。假设你有三个网页，内容如下。
我们根据这些内容创建一个散列表。
这个散列表的键为单词，值为包含指定单词的页面。现在假设有用户搜
索hi，在这种情况下，搜索引擎需要检查哪些页面包含hi。
搜索引擎发现页面A和B包含hi，因此将这些页面作为搜索结果呈现给用户。现在假设用户搜
索there。你知道，页面A和C包含它。非常简单，不是吗？这是一种很有用的数据结构：一个散
列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（inverted index），常用于创
建搜索引擎。如果你对搜索感兴趣，从反向索引着手研究是不错的选择。
11.3 傅里叶变换
绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。Better Explained是一个杰出
的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：给它一杯冰
172 第11 章 接下来如何做
沙，它能告诉你其中包含哪些成分①。换言之，给定一首歌曲，傅里叶变换能够将其中的各种频
率分离出来。
这种理念虽然简单，应用却极其广泛。例如，如果能够将歌曲分解为不同的频率，就可强化
你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音
乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的
贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理！
数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅
里叶变换还被用来地震预测和DNA分析。
使用傅里叶变换可创建类似于Shazam这样的音乐识别软件。傅里叶变换的用途极其广泛，你
遇到它的可能性极高！
11.4 并行算法
接下来的三个主题都与可扩展性和海量数据处理相关。我们身处一个处理器速度越来越快的
时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。但这个时代
已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。为提高算法的速度，你需要让它们
能够在多个内核中并行地执行！
来看一个简单的例子。在最佳情况下，排序算法的速度大致为O(n log n)。众所周知，对数组
进行排序时，除非使用并行算法，否则运行时间不可能为O(n)！对数组进行排序时，快速排序的
并行版本所需的时间为O(n)。
并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点
是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，
算法的速度也不可能提高一倍，其中的原因有两个。
 并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之
间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组
合并成一个有序数组，那么合并也是需要时间的。
 负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核
A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意
味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两
个内核都一样忙呢？
要改善性能和可扩展性，并行算法可能是不错的选择！
——————————
① 摘自Kalid发表在Better Explained上的文章“An Interactive Guide to the Fourier Transform”，网址为http://mng.bx/874X。
11.5 MapReduce 173
1
2
3
4
5
11
6
7
8
9
10
11.5 MapReduce
有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，
完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计
算机上运行。MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来
使用它。
11.5.1 分布式算法为何很有用
假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种
情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，
你需要通过Hadoop来使用MapReduce！
又假设你需要处理一个很长的清单，其中包含100万个职位，而每个职位处理起来需要10秒。
如果使用一台计算机来处理，将耗时数月！如果使用100台计算机来处理，可能几天就能完工。
分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理
念：映射（map）函数和归并（reduce）函数。
11.5.2 映射函数
映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。例如，下面的映
射函数将数组的每个元素翻倍。

arr1 = [1, 2, 3, 4, 5]
arr2 = map(lambda x: 2 * x, arr1)
[2, 4, 6, 8, 10]
arr2包含[2, 4, 6, 8, 10]：将数组arr1的每个元素都翻倍！将元素翻倍的速度非常快，
但如果要执行的操作需要更长的时间呢？请看下面的伪代码。
arr1 = # A list of URLs
arr2 = map(download_page, arr1)
在这个示例中，你有一个URL清单，需要下载每个URL指向的页面并将这些内容存储在数组
arr2中。对于每个URL，处理起来都可能需要几秒钟。如果总共有1000个URL，可能耗时几小时！
174 第11 章 接下来如何做
如果有100台计算机，而map能够自动将工作分配给这些计算机去完成就好了。这样就可同
时下载100个页面，下载速度将快得多！这就是MapReduce中“映射”部分基于的理念。
11.5.3 归并函数
归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。
而归并是将一个数组转换为一个元素。
下面是一个示例。
arr1 = [1, 2, 3, 4, 5]
reduce(lambda x,y: x+y, arr1)
15
在这个示例中，你将数组中的所有元素相加：1 + 2 + 3 + 4 + 5 = 15！这里不深入介绍归并，
网上有很多这方面的教程。
MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行
时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。
11.6 布隆过滤器和HyperLogLog
假设你管理着网站Reddit。每当有人发布链接时，你都要检查它以前是否发布过，因为之前
未发布过的故事更有价值。
又假设你在Google负责搜集网页，但只想搜集新出现的网页，因此需要判断网页是否搜集过。
在假设你管理着提供网址缩短服务的bit.ly，要避免将用户重定向到恶意网站。你有一个清单，
11.6 布隆过滤器和HyperLogLog 175
1
2
3
4
5
11
6
7
8
9
10
其中记录了恶意网站的URL。你需要确定要将用户重定向到的URL是否在这个清单中。
这些都是同一种类型的问题，涉及庞大的集合。
给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用散列表。
例如，Google可能有一个庞大的散列表，其中的键是已搜集的网页。
要判断是否已搜集adit.io，可在这个散列表中查找它。
adit.io是这个散列表中的一个键，这说明已搜集它。散列表的平均查找时间为O(1)，即查
找时间是固定的，非常好！
只是Google需要建立数万亿个网页的索引，因此这个散列表非常大，需要占用大量的存储空
间。Reddit和bit.ly也面临着这样的问题。面临海量数据，你需要创造性的解决方案！
11.6.1 布隆过滤器
布隆过滤器提供了解决之道。布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，
但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散
列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。
 可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。
176 第11 章 接下来如何做
 不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。
布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有
URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，
前面所有的示例都是这样的。对bit.ly而言，这样说完全可行：“我们认为这个网站可能是恶意的，
请倍加小心。”
11.6.2 HyperLogLog
HyperLogLog是一种类似于布隆过滤器的算法。如果Google要计算用户执行的不同搜索的数
量，或者Amazon要计算当天用户浏览的不同商品的数量，要回答这些问题，需要耗用大量的空
间！对Google来说，必须有一个日志，其中包含用户执行的不同搜索。有用户执行搜索时，Google
必须判断该搜索是否包含在日志中：如果答案是否定的，就必须将其加入到日志中。即便只记录
一天的搜索，这种日志也大得不得了！
HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，
但也八九不离十，而占用的内存空间却少得多。
面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！
11.7 SHA 算法
还记得第5章介绍的散列算法吗？我们回顾一下，假设你有一个键，需要将其相关联的值放
到数组中。
你使用散列函数来确定应将这个值放在数组的什么地方。
你将值放在这个地方。
11.7 SHA 算法 177
1
2
3
4
5
11
6
7
8
9
10
这样查找时间是固定的。当你想要知道指定键对应的值时，可再次执行散列函数，它将告诉
你这个值存储在什么地方，需要的时间为O(1)。
在这个示例中，你希望散列函数的结果是均匀分布的。散列函数接受一个字符串，并返回一
个索引号。
11.7.1 比较文件
另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串，SHA
返回其散列值。
这里的术语有点令人迷惑。SHA是一个散列函数，它生成一个散列值——一个较短的字符串。
用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。
对于每个不同的字符串，SHA生成的散列值都不同。
说 明
SHA 生成的散列值很长，这里截短了。
你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个4 GB
的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送
给朋友，而可计算它们的SHA散列值，再对结果进行比较。
178 第11 章 接下来如何做
11.7.2 检查密码
SHA还让你能在不知道原始字符串的情况下对其进行比较。例如，假设Gmail遭到攻击，攻
击者窃取了所有的密码！你的密码暴露了吗？没有，因为Google存储的并非密码，而是密码的
SHA散列值！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。
Google只是比较散列值，因此不必存储你的密码！SHA被广泛用于计算密码的散列值。这种
散列算法是单向的。你可根据字符串计算出散列值。
但你无法根据散列值推断出原始字符串。
这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码
转换为散列值，但反过来不行。
SHA实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1
已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。
当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。
11.8 局部敏感的散列算法
SHA还有一个重要特征，那就是局部不敏感的。假设你有一个字符串，并计算了其散列值。
如果你修改其中的一个字符，再计算其散列值，结果将截然不同！
这很好，让攻击者无法通过比较散列值是否类似来破解密码。
11.9 Diffie-Hellman 密钥交换 179
1
2
3
4
5
11
6
7
8
9
10
有时候，你希望结果相反，即希望散列函数是局部敏感的。在这种情况下，可使用Simhash。
如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比
较散列值来判断两个字符串的相似程度，这很有用！
 Google使用Simhash来判断网页是否已搜集。
 老师可以使用Simhash来判断学生的论文是否是从网上抄的。
 Scribd允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容！这个
网站可使用Simhash来检查上传的内容是否与小说《哈利·波特》类似，如果类似，就自
动拒绝。
需要检查两项内容的相似程度时，Simhash很有用。
11.9 Diffie-Hellman 密钥交换
这里有必要提一提Diffie-Hellman算法，它以优雅的方式解决了一个古老的问题：如何对消息
进行加密，以便只有收件人才能看懂呢？
最简单的方式是设计一种加密算法，如将a转换为1，b转换为2，以此类推。这样，如果我给
你发送消息“4,15,7”，你就可将其转换为“d,o,g”。但我们必须就加密算法达成一致，这种方式
才可行。我们不能通过电子邮件来协商，因为可能有人拦截电子邮件，获悉加密算法，进而破译
消息。即便通过会面来协商，这种加密算法也可能被猜出来——它并不复杂。因此，我们每天都
得修改加密算法，但这样我们每天都得会面！
即便我们能够每天修改，像这样简单的加密算法也很容易使用蛮力攻击破解。假设我看到消
息“9,6,13,13,16 24,16,19,13,5”，如果使用加密算法a = 1、b = 2等，转换结果将如下。
结果是一堆乱码。我们来尝试加密算法a = 2、b = 3等。
结果对了！像这样的简单加密算法很容易破解。在二战期间，德国人使用的加密算法比这复
杂得多，但还是被破解了。Diffie-Hellman算法解决了如下两个问题。
180 第11 章 接下来如何做
 双方无需知道加密算法。他们不必会面协商要使用的加密算法。
 要破解加密的消息比登天还难。
Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站
上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你
发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道
私钥，就只有你才能解密消息！
Diffie-Hellman算法及其替代者RSA依然被广泛使用。如果你对加密感兴趣，先着手研究
Diffie-Hellman算法是不错的选择：它既优雅又不难理解。
11.10 线性规划
最好的东西留到最后介绍。线性规划是我知道的最酷的算法之一。
线性规划用于在给定约束条件下最大限度地改善指定的指标。例如，假设你所在的公司生产
两种产品：衬衫和手提袋。衬衫每件利润2美元，需要消耗1米布料和5粒扣子；手提袋每个利润3
美元，需要消耗2米布料和2粒扣子。你有11米布料和20粒扣子，为最大限度地提高利润，该生产
多少件衬衫、多少个手提袋呢？
在这个例子中，目标是利润最大化，而约束条件是拥有的原材料数量。
再举一个例子。你是个政客，要尽可能多地获得支持票。你经过研究发现，平均而言，对于
每张支持票，在旧金山需要付出1小时的劳动（宣传、研究等）和2美元的开销，而在芝加哥需要
付出1.5小时的劳动和1美元的开销。在旧金山和芝加哥，你至少需要分别获得500和300张支持票。
你有50天的时间，总预算为1500美元。请问你最多可从这两个地方获得多少支持票？
这里的目标是支持票数最大化，而约束条件是时间和预算。
你可能在想，本书花了很大的篇幅讨论最优化，这与线性规划有何关系？所有的图算法都可
使用线性规划来实现。线性规划是一个宽泛得多的框架，图问题只是其中的一个子集。但愿你听
到这一点后心潮澎湃！
线性规划使用Simplex算法，这个算法很复杂，因此本书没有介绍。如果你对最优化感兴趣，
就研究研究线性规划吧！